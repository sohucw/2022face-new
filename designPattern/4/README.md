# 简述你了解的设计模式及应用场景

## 组件协作

1. Template Method 模式：
    - 模式定义：定义一个操作中的算法的骨架（稳定），将一些步骤（变化）延迟到子类中；
    - 应用场景：React 生命周期；
2. Observer 模式：
    - 模式定义：定义对象间的一种一对多（变化）的依赖关系，以便当一个对象（Subject）的状态发生变化时，所有依赖于它的对象都得到通知并自动更新。
    - 应用场景：Redux 实现。
3. Strategy 模式：
    - 定义：定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展、子类化）。
    - 应用：国际化、多种输入一种输出。

## 单一职责

1. Decorator 模式：
    - 模式定义：动态（组合）地给一个对象增加一些额外的职责，就增加功能而言，Decorator 模式比生成子类（继承）更加灵活（消除重复代码、减少子类个数）；
    - 应用场景：React 高阶组件、中间件。
2. Bridge 模式：
    - 模式定义：将抽象业务（业务功能）与实现部分（平台实现）分离，使它们都可以独立地变化。
    - 应用场景：组件组合功能。

## 对象创建

1. Factory Method 模式：
    - 模式定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使得一个类的实例化延迟（目的：解耦，手段：抽象）到子类。
    - 应用场景：React.createElement(...)、gin.Default(...)
2. Abstract Factory
    - 模式定义：提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定他们具体的类。
    - 应用场景：SQL API 类有多个成员类，比如连接类、创建类、操作类，将这些组合起来放在一个 Factory 类中，由这个类完成多个成员类的创建工作。

## 对象性能

1. Singleton 模式：
    - 模式定义：保证一个类只有一个实例，并提供一个该实例的全局访问点。
    - 应用场景：游戏中的主角类实例。
2. FlyWeight（享元模式）：
    - 模式定义：运行共享技术有效地支持大量细粒度的对象。
    - 应用场景：对象池优化。

## 接口隔离

1. Facade 模式：
    - 模式定义：为子系统中的一组接口提供一致（稳定）的界面，Facade 模式定义了一个高层接口，这个接口使得这个子系统更加容易使用（复用）。
    - 应用场景：各种硬件驱动。
2. Proxy 模式：
    - 模式定义：为其他对象提供一种代理以控制（隔离、使用接口）对这种对象的访问。
    - 应用场景：使用闭包导出方法（代理操作对象）。
3. Adapter 模式：
    - 模式定义：将一个类的接口转换为客户希望的另一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
    - 应用场景：Go 中的 `http.ListenAndServe` 所接受的结构体只需要实现 `ServeHTTP` 方法即可满足 `http` 的接口条件。
4. Composite 模式：
    - 模式定义：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性（稳定）。
    - 应用场景：在树形结构中，`Parent Node` 和 `Child Node` 都继承于同一抽象类 `Node`，都使用 `process` 方法来执行自身的方法。